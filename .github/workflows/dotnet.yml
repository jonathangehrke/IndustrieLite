name: .NET Build & Format

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

permissions:
  contents: read

env:
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  DOTNET_NOLOGO: true
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  NUGET_PACKAGES: ${{ github.workspace }}/.nuget/packages

concurrency:
  group: dotnet-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

defaults:
  run:
    shell: pwsh

jobs:
  build:
    name: .NET Build & Format / build
    runs-on: windows-latest
    timeout-minutes: 15

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-dotnet@v5
        with:
          global-json-file: global.json

      - name: Restore
        run: dotnet restore

      # 'verify-no-changes' blockiert absichtlich bei Formatierungsbedarf.
      # Nur PRs blockieren, Push bleibt grün.
      - name: Verify formatting (PRs only)
        if: ${{ github.event_name == 'pull_request' }}
        run: dotnet format IndustrieLite.sln --verify-no-changes

      # KEIN globales warnings-as-errors; CS1591 unterdrücken.
      # Deine Nullability-Errors greifen weiter projektseitig.
      - name: Build (no warnings-as-errors)
        run: dotnet build IndustrieLite.sln -c Release `
              -p:TreatWarningsAsErrors=false -p:WarningsAsErrors= -p:NoWarn=1591 --nologo

  unit-tests:
    name: .NET Build & Format / unit-tests
    runs-on: windows-latest
    needs: build
    timeout-minutes: 20

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-dotnet@v5
        with:
          global-json-file: global.json
      - name: Restore
        run: dotnet restore
      - name: Test
        run: dotnet test -c Release --no-build --logger "trx;LogFileName=testresults.trx"
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: testresults
          path: '**/*.trx'

  ps-checks:
    name: .NET Build & Format / ps-checks
    runs-on: windows-latest
    timeout-minutes: 10

    steps:
      - uses: actions/checkout@v4

      - name: Install PSScriptAnalyzer
        run: |
          Set-PSRepository PSGallery -InstallationPolicy Trusted
          Install-Module PSScriptAnalyzer -Scope CurrentUser -Force

      # Nur Errors brechen ab, Warnungen werden geloggt.
      - name: Lint PowerShell (errors fail, warnings pass)
        run: |
          $results = Invoke-ScriptAnalyzer -Path tools/ci -Recurse `
            -Settings tools/ci/PSScriptAnalyzerSettings.psd1
          $errors = $results | Where-Object Severity -eq 'Error'
          if ($errors) {
            $errors | Format-Table RuleName,Severity,ScriptName,Line,Message -AutoSize
            throw "PSScriptAnalyzer found $($errors.Count) error(s)."
          }
          $warnings = $results | Where-Object Severity -eq 'Warning'
          if ($warnings) {
            Write-Host "PSScriptAnalyzer warnings:"
            $warnings | Format-Table RuleName,Severity,ScriptName,Line,Message -AutoSize
          }

      # Eigene Repo-Checks (dürfen failen, wenn echte Verstöße)
      - name: Repo checks
        run: |
          ./tools/ci/CheckAutoloadOrder.ps1
          ./tools/ci/CheckManagerNoNodePath.ps1

  godot-headless:
    name: .NET Build & Format / godot-headless
    runs-on: windows-latest
    timeout-minutes: 30

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-dotnet@v5
        with:
          global-json-file: global.json

      # Godot 4.x (.NET) im selben Job installieren (nicht aus global.json ableiten).
      - name: Setup Godot (.NET)
        id: setup_godot
        uses: chickensoft-games/setup-godot@v2
        with:
          version: "4.4.1"
          use-dotnet: true

      # Nach dem Setup die tatsächlich ausführbare Datei finden und als Env exportieren.
      # Dadurch nutzen die PS-Skripte immer die EXE/CMD und NICHT den PATH-Fallback.
      - name: Resolve Godot executable & export
        id: resolve_godot
        run: |
          $ErrorActionPreference = 'Stop'

          # Debug: Zeige die Action-Outputs
          Write-Host "setup-godot outputs:"
          Write-Host "  path: ${{ steps.setup_godot.outputs.path }}"
          Write-Host "  cache-hit: ${{ steps.setup_godot.outputs.cache-hit }}"
          
          # Debug: Zeige relevante Umgebungsvariablen
          Write-Host "`nEnvironment variables:"
          Write-Host "  GODOT: $env:GODOT"
          Write-Host "  GODOT4: $env:GODOT4"
          Write-Host "  PATH contains godot: $($env:PATH -match 'godot')"

          function Find-GodotExe {
            param([string[]]$Seeds)

            $okExt = @('.exe','.cmd','.bat','.lnk')
            $namesExact = @(
              'godot.windows.headless.x86_64.exe',
              'godot.windows.editor.x86_64.exe',
              'Godot_v4.4.1-stable_mono_win64.exe',
              'Godot_v4.4-stable_mono_win64.exe',
              'godot.exe','Godot.exe','godot.cmd','godot.bat'
            )

            foreach ($seed in $Seeds) {
              if (-not $seed) { continue }
              
              Write-Host "Checking seed: $seed"
              
              if (-not (Test-Path $seed)) { 
                Write-Host "  -> Does not exist"
                continue 
              }
              
              $item = Get-Item $seed
              if ($item.PSIsContainer) {
                Write-Host "  -> Is directory, searching for executables..."
                
                # Debug: Zeige alle Dateien im Verzeichnis
                $allFiles = Get-ChildItem $item.FullName -File -ErrorAction SilentlyContinue
                Write-Host "  -> Total files in directory: $($allFiles.Count)"
                if ($allFiles.Count -le 20) {
                  foreach ($f in $allFiles) {
                    Write-Host "     - $($f.Name) [Size: $($f.Length) bytes]"
                  }
                }
                
                # Erst exakte Namen prüfen
                foreach ($n in $namesExact) {
                  $p = Join-Path $item.FullName $n
                  if (Test-Path $p) { 
                    Write-Host "  -> Found exact match: $p"
                    return $p 
                  }
                }
                
                # Dann nach godot*.exe Dateien suchen
                $files = Get-ChildItem $item.FullName -File -ErrorAction SilentlyContinue `
                       | Where-Object { $_.Name -match 'godot' -and $okExt -contains $_.Extension.ToLower() }
                
                if ($files) {
                  Write-Host "  -> Found godot executables: $($files.Count)"
                  foreach ($f in $files) {
                    Write-Host "     - $($f.FullName) [Size: $($f.Length) bytes]"
                  }
                  
                  # Priorisierung: headless > editor > andere
                  $pref = $files | Where-Object { $_.Name -match 'headless' } | Select-Object -First 1
                  if ($pref) { 
                    Write-Host "  -> Selected headless: $($pref.FullName)"
                    return $pref.FullName 
                  }
                  
                  # Bevorzuge größere Dateien (echte executables statt wrapper)
                  $sorted = $files | Sort-Object -Property Length -Descending
                  if ($sorted[0].Length -gt 1000000) {  # > 1MB deutet auf echte .exe hin
                    Write-Host "  -> Selected largest executable: $($sorted[0].FullName)"
                    return $sorted[0].FullName
                  }
                  
                  Write-Host "  -> Selected first: $($files[0].FullName)"
                  return $files[0].FullName 
                }
              } elseif ($item -is [System.IO.FileInfo]) {
                Write-Host "  -> Is file"
                
                # Wenn es eine Datei ohne Extension ist (wie "godot"), 
                # prüfe ob sie ausführbar ist oder ob eine .exe im selben Verzeichnis existiert
                if ([string]::IsNullOrEmpty($item.Extension)) {
                  Write-Host "  -> File without extension, checking if it's executable or has .exe variant"
                  
                  # Prüfe ob godot.exe im selben Verzeichnis existiert
                  $exeInDir = Join-Path $item.DirectoryName "$($item.Name).exe"
                  if (Test-Path $exeInDir) {
                    Write-Host "  -> Found .exe variant: $exeInDir"
                    return $exeInDir
                  }
                  
                  # Prüfe ob andere Godot executables im selben Verzeichnis sind
                  $dirFiles = Get-ChildItem $item.DirectoryName -File -ErrorAction SilentlyContinue `
                            | Where-Object { $_.Name -match 'godot' -and $okExt -contains $_.Extension.ToLower() }
                  if ($dirFiles) {
                    $headless = $dirFiles | Where-Object { $_.Name -match 'headless' } | Select-Object -First 1
                    if ($headless) {
                      Write-Host "  -> Found headless in same dir: $($headless.FullName)"
                      return $headless.FullName
                    }
                    Write-Host "  -> Found executable in same dir: $($dirFiles[0].FullName)"
                    return $dirFiles[0].FullName
                  }
                  
                  # Letzter Versuch: Nutze die Datei selbst (könnte ein Shell-Wrapper sein)
                  Write-Host "  -> Using the file itself as potential wrapper: $($item.FullName)"
                  return $item.FullName
                }
                
                if ($okExt -contains $item.Extension.ToLower()) { 
                  Write-Host "  -> Has valid extension, using it"
                  return $item.FullName 
                }
                
                # Check im selben Verzeichnis
                foreach ($n in $namesExact) {
                  $p = Join-Path $item.DirectoryName $n
                  if (Test-Path $p) { 
                    Write-Host "  -> Found in same dir: $p"
                    return $p 
                  }
                }
                
                $exeCandidate = "$($item.FullName).exe"
                if (Test-Path $exeCandidate) { 
                  Write-Host "  -> Found with .exe: $exeCandidate"
                  return $exeCandidate 
                }
              }
            }
            return $null
          }

          # Seeds: Action-Output hat höchste Priorität, dann Variablen + PATH + typische Orte
          $actionPath = "${{ steps.setup_godot.outputs.path }}"
          
          # Spezialbehandlung für C:\Users\runneradmin\bin\godot - prüfe auch das parent directory
          $binDir = "C:\Users\runneradmin\bin"
          
          $seeds = @(
            $actionPath,
            $binDir,  # Das bin-Verzeichnis selbst durchsuchen
            $env:GODOT4, 
            $env:GODOT,
            (Get-Command godot -ErrorAction SilentlyContinue)?.Source,
            (Get-Command godot4 -ErrorAction SilentlyContinue)?.Source,
            "$env:USERPROFILE\bin",  # Nochmal das bin-Verzeichnis
            "$env:USERPROFILE\bin\godot",
            "$env:USERPROFILE\.godot",
            "$env:RUNNER_TEMP",
            "$env:RUNNER_TEMP\godot",
            "C:\hostedtoolcache\windows\godot",
            "D:\a\_temp\godot",
            "${{ github.workspace }}\godot"
          )

          # Wenn action path ein Verzeichnis ist, auch parent directory prüfen
          if ($actionPath -and (Test-Path $actionPath -PathType Container)) {
            $parent = Split-Path $actionPath -Parent
            if ($parent) {
              $seeds += $parent
            }
          }

          Write-Host "`nSearching for Godot executable..."
          $exe = Find-GodotExe -Seeds $seeds
          
          if (-not $exe) {
            Write-Host "`nFailed to find Godot executable!"
            Write-Host "All seeds checked: $($seeds -join '; ')"
            
            # Extra debug: Zeige Inhalt einiger Verzeichnisse
            Write-Host "`nDirectory listings:"
            foreach ($dir in @($env:RUNNER_TEMP, "$env:USERPROFILE\bin", "C:\hostedtoolcache\windows")) {
              if (Test-Path $dir) {
                Write-Host "`n$dir contents:"
                Get-ChildItem $dir -ErrorAction SilentlyContinue | ForEach-Object {
                  Write-Host "  - $($_.Name)"
                }
              }
            }
            
            # Letzte Chance: Versuche godot direkt aufzurufen
            Write-Host "`nTrying direct godot command..."
            try {
              $godotVersion = & godot --version 2>&1
              if ($LASTEXITCODE -eq 0) {
                Write-Host "Direct godot call succeeded! Version: $godotVersion"
                Write-Host "Using 'godot' as fallback"
                $exe = "godot"
              }
            } catch {
              Write-Host "Direct godot call failed: $_"
            }
            
            if (-not $exe) {
              throw "Godot executable not found after setup-godot."
            }
          }

          "GODOT_BIN=$exe"  | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "GODOT4_BIN=$exe" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          "exe=$exe"        | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          Write-Host "`nResolved Godot executable: $exe"
          
          # Füge das Verzeichnis zum PATH hinzu, falls es eine echte Datei ist
          if ($exe -ne "godot" -and (Test-Path $exe)) {
            $godotDir = Split-Path $exe -Parent
            Write-Host "Adding to PATH: $godotDir"
            "PATH=$godotDir;$env:PATH" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          }

      # Sichtprüfung – wir rufen die gefundene EXE direkt auf (kein PATH nötig).
      - name: godot --version (verify)
        run: |
          Write-Host "Using GODOT_BIN=$env:GODOT_BIN"
          
          # Prüfe ob es eine .exe ist oder ein anderer Dateityp
          if (Test-Path $env:GODOT_BIN) {
            $item = Get-Item $env:GODOT_BIN
            if ($item.Extension -eq '.exe' -or $item.Extension -eq '.cmd' -or $item.Extension -eq '.bat') {
              & "$env:GODOT_BIN" --headless --version
            } else {
              # Könnte ein Shell-Wrapper sein, versuche es trotzdem
              try {
                & "$env:GODOT_BIN" --headless --version
              } catch {
                # Fallback: Versuche es als Kommando
                Write-Host "Direct execution failed, trying as command..."
                & cmd /c "`"$env:GODOT_BIN`" --headless --version"
              }
            }
          } elseif ($env:GODOT_BIN -eq "godot") {
            # Fallback case - use command directly
            & godot --headless --version
          } else {
            & "$env:GODOT_BIN" --headless --version
          }

      # Stelle sicher, dass godot im PATH verfügbar ist für die PowerShell-Skripte
      - name: Ensure godot is available in PATH
        run: |
          Write-Host "Checking if godot is available in PATH..."
          
          # Versuche godot direkt aufzurufen (mit --headless um Hängen zu vermeiden)
          $testSuccessful = $false
          try {
            # Verwende Start-Process mit Timeout für den Test
            $pinfo = New-Object System.Diagnostics.ProcessStartInfo
            $pinfo.FileName = "cmd.exe"
            $pinfo.Arguments = "/c godot --headless --version 2>&1"
            $pinfo.RedirectStandardOutput = $true
            $pinfo.RedirectStandardError = $true
            $pinfo.UseShellExecute = $false
            $pinfo.CreateNoWindow = $true
            
            $p = New-Object System.Diagnostics.Process
            $p.StartInfo = $pinfo
            
            try {
              $p.Start() | Out-Null
              if ($p.WaitForExit(5000)) {  # 5 Sekunden Timeout
                if ($p.ExitCode -eq 0) {
                  $output = $p.StandardOutput.ReadToEnd()
                  Write-Host "godot is already available in PATH"
                  Write-Host "Version: $output"
                  $testSuccessful = $true
                }
              } else {
                # Prozess hängt, beende ihn
                $p.Kill()
                Write-Host "godot command timed out"
              }
            } finally {
              $p.Dispose()
            }
          } catch {
            Write-Host "godot not found in PATH: $_"
          }
          
          if ($testSuccessful) {
            exit 0
          }
          
          Write-Host "Creating wrapper for godot..."
          
          # Erstelle einen Wrapper, falls godot nicht im PATH ist
          if ($env:GODOT_BIN -and (Test-Path $env:GODOT_BIN)) {
            $godotExe = $env:GODOT_BIN
            $godotDir = Split-Path $godotExe -Parent
            
            # Prüfe ob das Executable eine .exe ist
            $item = Get-Item $godotExe
            
            # Erstelle godot.cmd wrapper im gleichen Verzeichnis
            $wrapperPath = Join-Path $godotDir "godot.cmd"
            
            if ($item.Extension -eq '.exe') {
              # Direkt die .exe aufrufen
              $wrapperContent = "@echo off`r`n`"$godotExe`" %*"
            } else {
              # Für Dateien ohne/mit anderer Erweiterung
              # Versuche herauszufinden, ob es ein Skript oder Binary ist
              $firstBytes = [System.IO.File]::ReadAllBytes($godotExe) | Select-Object -First 2
              if ($firstBytes -and $firstBytes[0] -eq 0x4D -and $firstBytes[1] -eq 0x5A) {
                # MZ header = Windows executable
                $wrapperContent = "@echo off`r`n`"$godotExe`" %*"
              } else {
                # Möglicherweise ein Skript oder Wrapper
                $wrapperContent = "@echo off`r`ncmd /c `"$godotExe`" %*"
              }
            }
            
            [System.IO.File]::WriteAllText($wrapperPath, $wrapperContent, [System.Text.Encoding]::ASCII)
            Write-Host "Created wrapper at: $wrapperPath"
            Write-Host "Wrapper content:"
            Write-Host $wrapperContent
            
            # Füge das Verzeichnis zum PATH hinzu (für diesen Step)
            $env:PATH = "$godotDir;$env:PATH"
            
            # Teste ob es jetzt funktioniert (mit Timeout)
            Write-Host "`nTesting wrapper..."
            try {
              $pinfo = New-Object System.Diagnostics.ProcessStartInfo
              $pinfo.FileName = "cmd.exe"
              $pinfo.Arguments = "/c godot --headless --version"
              $pinfo.RedirectStandardOutput = $true
              $pinfo.RedirectStandardError = $true
              $pinfo.UseShellExecute = $false
              $pinfo.CreateNoWindow = $true
              
              $p = New-Object System.Diagnostics.Process
              $p.StartInfo = $pinfo
              
              $p.Start() | Out-Null
              if ($p.WaitForExit(5000)) {  # 5 Sekunden Timeout
                $output = $p.StandardOutput.ReadToEnd()
                $error = $p.StandardError.ReadToEnd()
                
                if ($p.ExitCode -eq 0) {
                  Write-Host "Success! godot is now available via wrapper"
                  Write-Host "Version: $output"
                } else {
                  Write-Host "Warning: Wrapper created but godot returned exit code $($p.ExitCode)"
                  Write-Host "Output: $output"
                  Write-Host "Error: $error"
                }
              } else {
                $p.Kill()
                Write-Host "Warning: godot command timed out even with wrapper"
                Write-Host "This may indicate the godot binary is not working correctly"
              }
              
              $p.Dispose()
            } catch {
              Write-Host "Warning: Could not verify wrapper functionality: $_"
            }
          } else {
            Write-Host "Warning: GODOT_BIN not set or file doesn't exist: $env:GODOT_BIN"
          }

      # Assemblies bauen, bevor Headless-Checks laufen.
      - name: Restore (C#)
        run: dotnet restore
      - name: Build (C#)
        run: dotnet build -c Release -p:TreatWarningsAsErrors=false --nologo

      # Import Godot resources (generiert .godot/imported/ für Assets)
      - name: Import Godot resources
        timeout-minutes: 5
        run: |
          Write-Host "Starting Godot resource import..."
          Write-Host "Using GODOT_BIN: $env:GODOT_BIN"

          # Verwende Start-Process wie in den Test-Skripten (funktioniert mit Files ohne Extension)
          $proc = Start-Process -FilePath "$env:GODOT_BIN" `
                                -ArgumentList @('--headless','--path','.','--editor','--quit') `
                                -NoNewWindow -PassThru -Wait

          $exitCode = $proc.ExitCode
          Write-Host "Import process exited with code: $exitCode"

          # Warte kurz um sicherzugehen dass Dateien geschrieben wurden
          Start-Sleep -Seconds 2

          # Prüfe ob .godot/imported existiert und Dateien enthält
          if (Test-Path ".godot/imported") {
            $importedFiles = Get-ChildItem ".godot/imported" -Recurse -File -ErrorAction SilentlyContinue | Measure-Object
            Write-Host "Import successful: $($importedFiles.Count) files in .godot/imported/"
            if ($importedFiles.Count -eq 0) {
              throw "Resource import failed - .godot/imported/ is empty"
            }
          } else {
            Write-Warning ".godot/imported directory not found!"
            throw "Resource import failed - no imported files generated"
          }

          Write-Host "Import complete and verified"

      # Headless-Prüfungen (nutzen jetzt GODOT_BIN direkt oder godot aus PATH).
      - name: BootSelfTest (headless)
        timeout-minutes: 5
        run: |
          # Setze GODOT_PATH für das Skript, falls verfügbar
          if ($env:GODOT_BIN) {
            $env:GODOT_PATH = $env:GODOT_BIN
            Write-Host "Setting GODOT_PATH=$env:GODOT_PATH for script"
          }
          ./tools/ci/RunBootSelfTest.ps1 -VerboseLog

      - name: DI Validation (headless)
        timeout-minutes: 5
        run: |
          # Setze GODOT_PATH für das Skript, falls verfügbar
          if ($env:GODOT_BIN) {
            $env:GODOT_PATH = $env:GODOT_BIN
            Write-Host "Setting GODOT_PATH=$env:GODOT_PATH for script"
          }
          ./tools/ci/RunDI.ps1 -VerboseLog